-- Subscription tizimi uchun jadval
CREATE TABLE IF NOT EXISTS public.subscriptions (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    plan_type text NOT NULL CHECK (plan_type IN ('monthly', 'yearly')),
    amount numeric(10, 2) NOT NULL,
    promo_code text,
    discount_amount numeric(10, 2) DEFAULT 0,
    final_amount numeric(10, 2) NOT NULL,
    started_at timestamptz NOT NULL DEFAULT now(),
    expires_at timestamptz NOT NULL,
    is_active boolean NOT NULL DEFAULT true,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX idx_subscriptions_user_id ON public.subscriptions(user_id);
CREATE INDEX idx_subscriptions_expires_at ON public.subscriptions(expires_at);
CREATE INDEX idx_subscriptions_is_active ON public.subscriptions(is_active);

COMMENT ON TABLE public.subscriptions IS 'Manages user subscriptions and payment plans.';

-- Promo kodlar jadvali
CREATE TABLE IF NOT EXISTS public.promo_codes (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    code text NOT NULL UNIQUE,
    discount_percent numeric(5, 2) DEFAULT 0,
    discount_amount numeric(10, 2) DEFAULT 0,
    free_days integer DEFAULT 0,
    max_uses integer DEFAULT NULL,
    used_count integer DEFAULT 0,
    is_active boolean NOT NULL DEFAULT true,
    expires_at timestamptz,
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX idx_promo_codes_code ON public.promo_codes(code);
CREATE INDEX idx_promo_codes_is_active ON public.promo_codes(is_active);

COMMENT ON TABLE public.promo_codes IS 'Manages promo codes for discounts and free trials.';

-- RLS policies
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can view their own subscriptions." ON public.subscriptions;
CREATE POLICY "Users can view their own subscriptions." ON public.subscriptions
    FOR SELECT USING (auth.current_user_id() = user_id);

DROP POLICY IF EXISTS "Users can insert their own subscriptions." ON public.subscriptions;
CREATE POLICY "Users can insert their own subscriptions." ON public.subscriptions
    FOR INSERT WITH CHECK (auth.current_user_id() = user_id);

DROP POLICY IF EXISTS "Users can update their own subscriptions." ON public.subscriptions;
CREATE POLICY "Users can update their own subscriptions." ON public.subscriptions
    FOR UPDATE USING (auth.current_user_id() = user_id);

-- Promo codes are readable by authenticated users
ALTER TABLE public.promo_codes ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Promo codes are readable." ON public.promo_codes;
CREATE POLICY "Promo codes are readable." ON public.promo_codes
    FOR SELECT USING (true);

GRANT ALL ON public.subscriptions TO authenticated;
GRANT SELECT ON public.promo_codes TO authenticated;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO authenticated;

-- Demo promo kodlar qo'shish
INSERT INTO public.promo_codes (code, discount_percent, discount_amount, free_days, max_uses, is_active) VALUES
('SMART2026', 10, 0, 0, 100, true),
('WELCOME50', 50, 0, 0, 50, true),
('FREEMONTH', 0, 0, 30, 20, true),
('DEMO100', 100, 0, 0, 10, true)
ON CONFLICT (code) DO NOTHING;

-- Function to check if user has active subscription
CREATE OR REPLACE FUNCTION public.has_active_subscription(p_user_id uuid)
RETURNS boolean AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM public.subscriptions
        WHERE user_id = p_user_id
        AND is_active = true
        AND expires_at > now()
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get user's active subscription
CREATE OR REPLACE FUNCTION public.get_active_subscription(p_user_id uuid)
RETURNS TABLE (
    id bigint,
    plan_type text,
    expires_at timestamptz,
    days_remaining integer
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        s.id,
        s.plan_type,
        s.expires_at,
        GREATEST(0, EXTRACT(EPOCH FROM (s.expires_at - now()))::integer / 86400)::integer as days_remaining
    FROM public.subscriptions s
    WHERE s.user_id = p_user_id
    AND s.is_active = true
    AND s.expires_at > now()
    ORDER BY s.expires_at DESC
    LIMIT 1;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to validate and apply promo code
CREATE OR REPLACE FUNCTION public.validate_promo_code(p_code text)
RETURNS TABLE (
    valid boolean,
    discount_percent numeric,
    discount_amount numeric,
    free_days integer,
    message text
) AS $$
DECLARE
    promo_record public.promo_codes%ROWTYPE;
BEGIN
    SELECT * INTO promo_record
    FROM public.promo_codes
    WHERE UPPER(code) = UPPER(p_code)
    AND is_active = true
    AND (expires_at IS NULL OR expires_at > now())
    AND (max_uses IS NULL OR used_count < max_uses);
    
    IF NOT FOUND THEN
        RETURN QUERY SELECT false, 0::numeric, 0::numeric, 0, 'Promo kod topilmadi yoki muddati o\'tgan'::text;
        RETURN;
    END IF;
    
    RETURN QUERY SELECT 
        true,
        promo_record.discount_percent,
        promo_record.discount_amount,
        promo_record.free_days,
        'Promo kod qabul qilindi'::text;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to increment promo code usage
CREATE OR REPLACE FUNCTION public.increment_promo_usage(p_code text)
RETURNS void AS $$
BEGIN
    UPDATE public.promo_codes
    SET used_count = used_count + 1
    WHERE UPPER(code) = UPPER(p_code);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
