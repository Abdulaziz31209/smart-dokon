--  smart-dokon initial schema
-- Ushbu sxema biznesni boshqarish tizimining barcha asosiy talablarini qamrab oladi.

-- Foydalanuvchi rollari uchun ENUM
CREATE TYPE public.user_role AS ENUM ('admin', 'seller', 'stock_manager');

-- 1. PROFILES: Foydalanuvchilarga oid qo'shimcha ma'lumotlar
-- auth.users jadvalini kengaytiradi. Har bir foydalanuvchi bitta biznesga tegishli bo'ladi.
CREATE TABLE public.profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name text,
    username text NOT NULL UNIQUE,
    shop_name text,
    shop_type text,
    phone text,
    birth_date date,
    role public.user_role NOT NULL DEFAULT 'admin',
    goals jsonb, -- { "daily": 15000000, "weekly": 100000000, ... }
    is_active boolean NOT NULL DEFAULT true,
    created_at timestamptz NOT NULL DEFAULT now()
);

-- Profiles jadvali uchun commentlar
COMMENT ON TABLE public.profiles IS 'Stores public-facing profile information for each user.';
COMMENT ON COLUMN public.profiles.id IS 'References auth.users.id and serves as the primary key.';
COMMENT ON COLUMN public.profiles.role IS 'Defines the access level and permissions for the user.';

-- 2. CATEGORIES: Mahsulotlar uchun kategoriyalar
CREATE TABLE public.categories (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL UNIQUE,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamptz NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.categories IS 'Stores product categories managed by users.';

-- 3. PRODUCTS: Mahsulotlar va ularning zaxirasi
CREATE TABLE public.products (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    category_id bigint REFERENCES public.categories(id) ON DELETE SET NULL,
    name text NOT NULL,
    sku text,
    price numeric(10, 2) NOT NULL DEFAULT 0,
    cost numeric(10, 2) NOT NULL DEFAULT 0,
    stock integer NOT NULL DEFAULT 0,
    min_stock_level integer NOT NULL DEFAULT 10,
    active boolean NOT NULL DEFAULT true,
    created_at timestamptz NOT NULL DEFAULT now()
);
-- Mahsulotlar jadvali uchun index
CREATE INDEX idx_products_user_id ON public.products(user_id);
CREATE INDEX idx_products_sku ON public.products(sku);
COMMENT ON TABLE public.products IS 'Manages all products, their pricing, and stock levels.';

-- 4. EMPLOYEES: Xodimlar va ularning ma'lumotlari
CREATE TABLE public.employees (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name text NOT NULL,
    position text,
    phone text,
    email text,
    salary numeric(10, 2) DEFAULT 0,
    is_active boolean NOT NULL DEFAULT true,
    created_at timestamptz NOT NULL DEFAULT now()
);
CREATE INDEX idx_employees_user_id ON public.employees(user_id);
COMMENT ON TABLE public.employees IS 'Stores information about employees.';

-- 5. CUSTOMERS: Xaridorlar, ayniqsa qarzni boshqarish uchun
CREATE TABLE public.customers (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name text NOT NULL,
    phone text,
    address text,
    created_at timestamptz NOT NULL DEFAULT now()
);
CREATE INDEX idx_customers_user_id ON public.customers(user_id);
COMMENT ON TABLE public.customers IS 'Manages customer data, primarily for debt tracking.';

-- 6. SALES: Har bir sotuv tranzaksiyasi
CREATE TABLE public.sales (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    employee_id bigint REFERENCES public.employees(id) ON DELETE SET NULL,
    customer_id bigint REFERENCES public.customers(id) ON DELETE SET NULL,
    total_price numeric(12, 2) NOT NULL,
    payment_method text NOT NULL CHECK (payment_method IN ('Naqd', 'Karta', 'Payme', 'Click', 'Qarz')),
    sale_date timestamptz NOT NULL DEFAULT now()
);
CREATE INDEX idx_sales_user_id_date ON public.sales(user_id, sale_date);
COMMENT ON TABLE public.sales IS 'Records every sales transaction.';

-- 7. SALE_ITEMS: Sotuvdagi har bir mahsulot
-- Bir sotuvda bir nechta mahsulot bo'lishi mumkin
CREATE TABLE public.sale_items (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sale_id bigint NOT NULL REFERENCES public.sales(id) ON DELETE CASCADE,
    product_id bigint NOT NULL REFERENCES public.products(id) ON DELETE RESTRICT,
    quantity integer NOT NULL,
    unit_price numeric(10, 2) NOT NULL,
    total_price numeric(12, 2) NOT NULL
);
CREATE INDEX idx_sale_items_sale_id ON public.sale_items(sale_id);
COMMENT ON TABLE public.sale_items IS 'Details each item within a sale.';

-- 8. INVENTORY_LOGS: Ombor harakati tarixi (kirim-chiqim)
CREATE TYPE public.inventory_log_type AS ENUM ('stock_in', 'stock_out', 'correction');
CREATE TABLE public.inventory_logs (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    product_id bigint NOT NULL REFERENCES public.products(id) ON DELETE CASCADE,
    sale_item_id bigint REFERENCES public.sale_items(id) ON DELETE SET NULL, -- Sotuv tufayli chiqim
    change integer NOT NULL,
    new_stock integer NOT NULL,
    type public.inventory_log_type NOT NULL,
    reason text,
    created_at timestamptz NOT NULL DEFAULT now()
);
CREATE INDEX idx_inventory_logs_product_id ON public.inventory_logs(product_id);
COMMENT ON TABLE public.inventory_logs IS 'Audits every change in product stock levels.';

-- 9. EXPENSES: Operatsion xarajatlar
CREATE TABLE public.expenses (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title text NOT NULL,
    amount numeric(10, 2) NOT NULL,
    category text,
    expense_date date NOT NULL DEFAULT CURRENT_DATE,
    created_at timestamptz NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.expenses IS 'Tracks business operational expenses.';

-- 10. DEBTS (Accounts Receivable): Mijozlar qarzdorligi
CREATE TABLE public.debts (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    customer_id bigint NOT NULL REFERENCES public.customers(id) ON DELETE CASCADE,
    sale_id bigint REFERENCES public.sales(id) ON DELETE SET NULL, -- Qarzga olingan sotuv
    amount numeric(12, 2) NOT NULL,
    amount_paid numeric(12, 2) NOT NULL DEFAULT 0,
    is_paid boolean NOT NULL DEFAULT false,
    due_date date,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz
);
CREATE INDEX idx_debts_customer_id ON public.debts(customer_id);
COMMENT ON TABLE public.debts IS 'Manages customer debts (accounts receivable).';


-- TRIGGERS and FUNCTIONS

-- 1. Function to automatically create a profile when a new user signs up.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, username, full_name, shop_name)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data->>'username',
    NEW.raw_user_meta_data->>'full_name',
    NEW.raw_user_meta_data->>'shop_name'
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2. Trigger to call the function upon new user creation.
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- 3. Function to update product stock and log the change after a sale.
CREATE OR REPLACE FUNCTION public.handle_sale_stock_change()
RETURNS TRIGGER AS $$
DECLARE
  new_stock_level int;
BEGIN
  -- Update product stock
  UPDATE public.products
  SET stock = stock - NEW.quantity
  WHERE id = NEW.product_id
  RETURNING stock INTO new_stock_level;

  -- Create inventory log
  INSERT INTO public.inventory_logs (user_id, product_id, sale_item_id, change, new_stock, type, reason)
  VALUES ((SELECT user_id FROM public.sales WHERE id = NEW.sale_id), NEW.product_id, NEW.id, -NEW.quantity, new_stock_level, 'stock_out', 'Sale');
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 4. Trigger to call the function after a sale_item is inserted.
CREATE TRIGGER on_sale_item_insert
  AFTER INSERT ON public.sale_items
  FOR EACH ROW EXECUTE PROCEDURE public.handle_sale_stock_change();


-- ROW-LEVEL SECURITY (RLS) POLICIES

-- Helper function to get the current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS uuid AS $$
BEGIN
  RETURN auth.uid();
END;
$$ LANGUAGE plpgsql;


-- Universal policy for tables with user_id
CREATE OR REPLACE FUNCTION apply_rls_to_table(table_name text) RETURNS void AS $$
BEGIN
  EXECUTE format('ALTER TABLE public.%I ENABLE ROW LEVEL SECURITY;', table_name);
  
  EXECUTE format('DROP POLICY IF EXISTS "Users can manage their own %1$s." ON public.%1$I;', table_name);
  EXECUTE format('CREATE POLICY "Users can manage their own %1$s." ON public.%1$I FOR ALL
    USING (auth.current_user_id() = user_id)
    WITH CHECK (auth.current_user_id() = user_id);', table_name);
END;
$$ LANGUAGE plpgsql;

-- Apply policies to all relevant tables
SELECT apply_rls_to_table('products');
SELECT apply_rls_to_table('categories');
SELECT apply_rls_to_table('employees');
SELECT apply_rls_to_table('customers');
SELECT apply_rls_to_table('sales');
SELECT apply_rls_to_table('inventory_logs');
SELECT apply_rls_to_table('expenses');
SELECT apply_rls_to_table('debts');

-- Special RLS for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;
CREATE POLICY "Users can update their own profile." ON public.profiles
  FOR UPDATE USING (auth.current_user_id() = id);
  
DROP POLICY IF EXISTS "Profiles are public." ON public.profiles;
CREATE POLICY "Profiles are public." ON public.profiles
  FOR SELECT USING (true);

-- Special RLS for sale_items (based on the parent sale)
ALTER TABLE public.sale_items ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can manage their own sale items." ON public.sale_items;
CREATE POLICY "Users can manage their own sale items." ON public.sale_items FOR ALL
  USING (auth.current_user_id() = (SELECT user_id FROM public.sales WHERE id = sale_id))
  WITH CHECK (auth.current_user_id() = (SELECT user_id FROM public.sales WHERE id = sale_id));

-- Give authenticated users access to the tables
GRANT ALL ON public.profiles TO authenticated;
GRANT ALL ON public.products TO authenticated;
GRANT ALL ON public.categories TO authenticated;
GRANT ALL ON public.employees TO authenticated;
GRANT ALL ON public.customers TO authenticated;
GRANT ALL ON public.sales TO authenticated;
GRANT ALL ON public.sale_items TO authenticated;
GRANT ALL ON public.inventory_logs TO authenticated;
GRANT ALL ON public.expenses TO authenticated;
GRANT ALL ON public.debts TO authenticated;

-- Grant usage on sequences
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO authenticated;
